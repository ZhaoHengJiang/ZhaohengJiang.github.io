<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Go闭包 | ZiggyJiang的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="闭包的定义闭包是由&#x3D;&#x3D;函数&#x3D;&#x3D;及其相关的&#x3D;&#x3D;引用环境&#x3D;&#x3D;组合而成，举个例子 12345678910111213141516171819202122232425262728package mainimport (	&quot;fmt&quot;)func normalFunc(a int, x *int) int &amp;#123;	(*x)++	return a + *x&amp;#125;func Closu">
<meta property="og:type" content="article">
<meta property="og:title" content="Go闭包">
<meta property="og:url" content="http://example.com/2021/04/29/GoClosure/index.html">
<meta property="og:site_name" content="ZiggyJiang的博客">
<meta property="og:description" content="闭包的定义闭包是由&#x3D;&#x3D;函数&#x3D;&#x3D;及其相关的&#x3D;&#x3D;引用环境&#x3D;&#x3D;组合而成，举个例子 12345678910111213141516171819202122232425262728package mainimport (	&quot;fmt&quot;)func normalFunc(a int, x *int) int &amp;#123;	(*x)++	return a + *x&amp;#125;func Closu">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-04-29T13:41:56.000Z">
<meta property="article:modified_time" content="2021-05-04T19:10:33.798Z">
<meta property="article:tag" content="Go">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="ZiggyJiang的博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">ZiggyJiang的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">保持学习 保持谦虚</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-GoClosure" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/29/GoClosure/" class="article-date">
  <time class="dt-published" datetime="2021-04-29T13:41:56.000Z" itemprop="datePublished">2021-04-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Go闭包
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="闭包的定义"><a href="#闭包的定义" class="headerlink" title="闭包的定义"></a>闭包的定义</h2><p>闭包是由==函数==及其相关的==引用环境==组合而成，举个例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">normalFunc</span><span class="params">(a <span class="keyword">int</span>, x *<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	(*x)++</span><br><span class="line">	<span class="keyword">return</span> a + *x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Closures</span><span class="params">()</span> <span class="title">func</span><span class="params">(a <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	x := <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(a <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">		x++</span><br><span class="line">		<span class="keyword">return</span> a + x</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fc := Closures()</span><br><span class="line">	fmt.Println(fc(<span class="number">5</span>)) <span class="comment">//6</span></span><br><span class="line">	fmt.Println(fc(<span class="number">5</span>)) <span class="comment">//7</span></span><br><span class="line"></span><br><span class="line">	x := <span class="number">0</span></span><br><span class="line">	fmt.Println(normalFunc(<span class="number">5</span>, &amp;x)) <span class="comment">//6</span></span><br><span class="line">	fmt.Println(normalFunc(<span class="number">5</span>, &amp;x)) <span class="comment">//7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，返回闭包的函数与输入引用的函数的输出结果相同，闭包函数<code>fc</code>相当于引用了环境（函数<code>Closures()</code>）中的变量<code>x</code>。</p>
<p>但如果以C++的特性来看，函数<code>Closure()</code>中的<code>x</code>是一个分配在栈上的局部变量，在函数<code>Closure()</code>返回后，对应的栈也随之失效，变量<code>x</code>也理应失效。但Go与C++有着不一样的语法特性。</p>
<h2 id="escape-analyze"><a href="#escape-analyze" class="headerlink" title="escape analyze"></a>escape analyze</h2><p>举个例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> *<span class="title">Cursor</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c Cursor</span><br><span class="line">    c.X = <span class="number">500</span></span><br><span class="line">    noinline()</span><br><span class="line">    <span class="keyword">return</span> &amp;c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Cursor是一个结构体，这种写法在C++语言中是不允许的，因为变量c是在栈上分配的，当函数f返回后c的空间就失效了。但是，在Go语言规范中有说明，这种写法在Go语言中合法的。语言会自动地识别出这种情况并在堆上分配c的内存，而不是函数f的栈上。</p>
<p>为了验证这一点，可以观察函数f生成的汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MOVQ    $type.&quot;&quot;.Cursor+0(SB),(SP)    &#x2F;&#x2F; 取变量c的类型，也就是Cursor</span><br><span class="line">PCDATA    $0,$16</span><br><span class="line">PCDATA    $1,$0</span><br><span class="line">CALL    ,runtime.new(SB)    &#x2F;&#x2F; 调用new函数，相当于new(Cursor)</span><br><span class="line">PCDATA    $0,$-1</span><br><span class="line">MOVQ    8(SP),AX    &#x2F;&#x2F; 取c.X的地址放到AX寄存器</span><br><span class="line">MOVQ    $500,(AX)    &#x2F;&#x2F; 将AX存放的内存地址的值赋为500</span><br><span class="line">MOVQ    AX,&quot;&quot;.~r0+24(FP)</span><br><span class="line">ADDQ    $16,SP</span><br></pre></td></tr></table></figure>

<p>识别出变量需要在堆上分配，是由编译器的一种叫escape analyze的技术实现的。如果输入命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build --gcflags=-m main.go</span><br></pre></td></tr></table></figure>

<p>可以看到输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./main.go:20: moved to heap: c</span><br><span class="line">./main.go:23: &amp;c escapes to heap</span><br></pre></td></tr></table></figure>

<p>表示c逃逸了，被移到堆中。escape analyze可以分析出变量的作用范围，这是对垃圾回收很重要的一项技术。</p>
<h2 id="闭包与匿名函数"><a href="#闭包与匿名函数" class="headerlink" title="闭包与匿名函数"></a>闭包与匿名函数</h2><p>闭包可以认为是匿名函数的特殊情况，为了更好的理解闭包，我们先深入了解下匿名函数</p>
<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>匿名函数与正常函数的区别不大，只是这个函数没有名字。其对比如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">(message <span class="keyword">string</span>)</span></span> &#123; <span class="comment">// 声明一个正常的函数</span></span><br><span class="line">    <span class="built_in">println</span>(message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Foo(<span class="string">&quot;hello world!&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(message <span class="keyword">string</span>)</span></span> &#123; <span class="comment">//声明匿名函数并执行</span></span><br><span class="line">       <span class="built_in">println</span>(message)</span><br><span class="line">   &#125;(<span class="string">&quot;hello world!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然两者的作用并无区别，但底层的实现却有着小小的不同。在这我们用一个简短的例子来看下。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc</span><span class="params">(message <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        f := <span class="function"><span class="keyword">func</span><span class="params">(message <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">                <span class="built_in">println</span>(message)</span><br><span class="line">        &#125;</span><br><span class="line">        f(<span class="number">0x100</span>)</span><br><span class="line">        myFunc(<span class="number">0x100</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将上面的代码编译</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -gcflags <span class="string">&quot;-N -l -m&quot;</span> -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>生成一个 elf 格式的文件 main。</p>
<p>然后我们通过 go 提供的反汇编工具，反编译我们刚刚生成的 test 文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$go tool objdump -s &quot;main\.main&quot; .&#x2F;test</span><br><span class="line">TEXT main.main(SB) &#x2F;root&#x2F;data&#x2F;example&#x2F;closures&#x2F;anonymous_func.go</span><br><span class="line">     anonymous_func.go:7     0x401040        64488b0c25f8ffffff      FS MOVQ FS:0xfffffff8, CX</span><br><span class="line">     anonymous_func.go:7     0x401049        483b6110                CMPQ 0x10(CX), SP</span><br><span class="line">     anonymous_func.go:7     0x40104d        7637                    JBE 0x401086</span><br><span class="line">     anonymous_func.go:7     0x40104f        4883ec10                SUBQ $0x10, SP</span><br><span class="line">     anonymous_func.go:8     0x401053        488d1d16830800          LEAQ 0x88316(IP), BX</span><br><span class="line">     anonymous_func.go:8     0x40105a        48895c2408              MOVQ BX, 0x8(SP)</span><br><span class="line">     anonymous_func.go:11    0x40105f        48c7042400010000        MOVQ $0x100, 0(SP)</span><br><span class="line">     anonymous_func.go:11    0x401067        488b5c2408              MOVQ 0x8(SP), BX</span><br><span class="line">     anonymous_func.go:11    0x40106c        4889da                  MOVQ BX, DX</span><br><span class="line">     anonymous_func.go:11    0x40106f        488b1a                  MOVQ 0(DX), BX</span><br><span class="line">     anonymous_func.go:11    0x401072        ffd3                    CALL BX</span><br><span class="line">     anonymous_func.go:12    0x401074        48c7042400010000        MOVQ $0x100, 0(SP)</span><br><span class="line">     anonymous_func.go:12    0x40107c        e87fffffff              CALL main.myFunc(SB)</span><br><span class="line">     anonymous_func.go:13    0x401081        4883c410                ADDQ $0x10, SP</span><br><span class="line">     anonymous_func.go:13    0x401085        c3                      RET</span><br><span class="line">     anonymous_func.go:7     0x401086        e8b59f0400              CALL runtime.morestack_noctxt(SB)</span><br><span class="line">     anonymous_func.go:7     0x40108b        ebb3                    JMP main.main(SB)</span><br><span class="line">     anonymous_func.go:7     0x40108d        cc                      INT $0x3</span><br><span class="line">     anonymous_func.go:7     0x40108e        cc                      INT $0x3</span><br><span class="line">     anonymous_func.go:7     0x40108f        cc                      INT $0x3</span><br><span class="line"></span><br><span class="line">     ...</span><br></pre></td></tr></table></figure>

<p>上面的汇编输出中我们可以看到一共有三次 <code>CALL</code>， 排除调最后那个 <code>runtime</code> 的 <code>CALL</code> ，剩下两次分别对应了匿名函数调用以及正常的函数调用。而两次的区别在于正常的函数是 <code>CALL main.myFunc(SB)</code> , 匿名函数的调用是 <code>CALL BX</code> 。这两种不同的调用方式意味着什么？我们可以通过 gdb 来动态的跟踪这段代码来具体分析一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">gdb main</span><br><span class="line">Reading symbols from test...done.</span><br><span class="line">(gdb) b main.main</span><br><span class="line">Breakpoint 1 at 0x401040: file &#x2F;root&#x2F;data&#x2F;example&#x2F;closures&#x2F;anonymous_func.go, line 7.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: &#x2F;root&#x2F;data&#x2F;example&#x2F;closures&#x2F;test</span><br><span class="line">[New LWP 2067]</span><br><span class="line">[New LWP 2068]</span><br><span class="line">[New LWP 2069]</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main.main () at &#x2F;root&#x2F;data&#x2F;example&#x2F;closures&#x2F;anonymous_func.go:7</span><br><span class="line">7       func main() &#123;</span><br><span class="line">(gdb) l</span><br><span class="line">2</span><br><span class="line">3       func myFunc(message int) &#123;</span><br><span class="line">4               println(message)</span><br><span class="line">5       &#125;</span><br><span class="line">6</span><br><span class="line">7       func main() &#123;</span><br><span class="line">8               f :&#x3D; func(message int) &#123;</span><br><span class="line">9                       println(message)</span><br><span class="line">10              &#125;</span><br><span class="line">11              f(0x100)</span><br><span class="line">(gdb) i locals</span><br><span class="line">f &#x3D; &#123;void (int)&#125; 0xc820039f40</span><br><span class="line">(gdb) x&#x2F;1xg 0xc820039f40</span><br><span class="line">0xc820039f40:   0x000000c820000180</span><br></pre></td></tr></table></figure>

<p>上面在 gdb 里面把断点设置在 <code>main.main</code> 处，然后通过输出当前的环境变量可以看到变量 f。这时候显示 f 指针指向的内存内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b 11</span><br><span class="line">Breakpoint 2 at 0x40105f: file &#x2F;root&#x2F;data&#x2F;example&#x2F;closures&#x2F;anonymous_func.go, line 11.</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 2, main.main () at &#x2F;root&#x2F;data&#x2F;example&#x2F;closures&#x2F;anonymous_func.go:11</span><br><span class="line">11              f(0x100)</span><br><span class="line">(gdb) i locals</span><br><span class="line">f &#x3D; &#123;void (int)&#125; 0xc820039f40</span><br><span class="line">(gdb) x&#x2F;1xg 0xc820039f40</span><br><span class="line">0xc820039f40:   0x0000000000489370</span><br><span class="line">(gdb) i symbol 0x0000000000489370</span><br><span class="line">main.main.func1.f in section .rodata of &#x2F;root&#x2F;data&#x2F;example&#x2F;closures&#x2F;test</span><br><span class="line">(gdb) x&#x2F;2xg 0x0000000000489370</span><br><span class="line">0x489370 &lt;main.main.func1.f&gt;:   0x0000000000401090      0x0000000000441fa0</span><br><span class="line">(gdb) i symbol 0x0000000000401090</span><br><span class="line">main.main.func1 in section .text of &#x2F;root&#x2F;data&#x2F;example&#x2F;closures&#x2F;test</span><br></pre></td></tr></table></figure>

<p>然后在调用匿名函数 <code>f</code> 的地方再设置一个断点， <code>c</code> 让程序执行到新的断点。再输出 f 指针指向的内存，发现里面的内容已经改变了，输出符号名可以看到符号是 <code>main.main.func1.f</code>, 这个是编译器提我们生成的符号名，然后看一下这个地址指向的内容，会发现 <code>main.main.func1</code> ，也就是就是我们的匿名函数。接着跟</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">(gdb) i r</span><br><span class="line">  rax            0xc820000180     859530330496</span><br><span class="line">  rbx            0x489370 4756336</span><br><span class="line">  ...</span><br><span class="line">(gdb) disassemble</span><br><span class="line">Dump of assembler code for function main.main:</span><br><span class="line">  0x0000000000401040 &lt;+0&gt;:     mov    %fs:0xfffffffffffffff8,%rcx</span><br><span class="line">  0x0000000000401049 &lt;+9&gt;:     cmp    0x10(%rcx),%rsp</span><br><span class="line">  0x000000000040104d &lt;+13&gt;:    jbe    0x401086 &lt;main.main+70&gt;</span><br><span class="line">  0x000000000040104f &lt;+15&gt;:    sub    $0x10,%rsp</span><br><span class="line">  0x0000000000401053 &lt;+19&gt;:    lea    0x88316(%rip),%rbx        # 0x489370 &lt;main.main.func1.f&gt;</span><br><span class="line">  0x000000000040105a &lt;+26&gt;:    mov    %rbx,0x8(%rsp)</span><br><span class="line">&#x3D;&gt; 0x000000000040105f &lt;+31&gt;:    movq   $0x100,(%rsp)</span><br><span class="line">  0x0000000000401067 &lt;+39&gt;:    mov    0x8(%rsp),%rbx</span><br><span class="line">  0x000000000040106c &lt;+44&gt;:    mov    %rbx,%rdx</span><br><span class="line">  0x000000000040106f &lt;+47&gt;:    mov    (%rdx),%rbx</span><br><span class="line">  0x0000000000401072 &lt;+50&gt;:    callq  *%rbx</span><br><span class="line">  0x0000000000401074 &lt;+52&gt;:    movq   $0x100,(%rsp)</span><br><span class="line">  0x000000000040107c &lt;+60&gt;:    callq  0x401000 &lt;main.myFunc&gt;</span><br><span class="line">  0x0000000000401081 &lt;+65&gt;:    add    $0x10,%rsp</span><br><span class="line">  0x0000000000401085 &lt;+69&gt;:    retq</span><br><span class="line">  0x0000000000401086 &lt;+70&gt;:    callq  0x44b040 &lt;runtime.morestack_noctxt&gt;</span><br><span class="line">  0x000000000040108b &lt;+75&gt;:    jmp    0x401040 &lt;main.main&gt;</span><br><span class="line">  0x000000000040108d &lt;+77&gt;:    int3</span><br><span class="line">  0x000000000040108e &lt;+78&gt;:    int3</span><br><span class="line">  0x000000000040108f &lt;+79&gt;:    int3</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) p $rsp</span><br><span class="line">$2 &#x3D; (void *) 0xc820039f38</span><br><span class="line">(gdb) x&#x2F;1xg 0xc820039f38</span><br><span class="line">0xc820039f38:   0x0000000000000000</span><br><span class="line">(gdb) ni</span><br><span class="line">0x0000000000401067      11              f(0x100)</span><br><span class="line">(gdb) x&#x2F;1xg 0xc820039f38</span><br><span class="line">0xc820039f38:   0x0000000000000100</span><br></pre></td></tr></table></figure>

<p>输出寄存器里面的值看一下，可以注意到寄存器 <code>rbx</code> 的内存地址是 <code>func1.f</code> 的地址。然后反编译可以看到执行到了 +31 这一行，将常量 <code>0x100</code> 放在 rsp 内指针指向的内存地址。输出 rsp 的内容，然后显示地址指向内存的内容，可以看到是 <code>0x0000000000000000</code>，输入 <code>ni</code> 执行这一行汇编之后再看，就看到内存里面的内容变成了 <code>0x0000000000000100</code>，也就是我们输入常量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">(gdb) ni</span><br><span class="line">0x000000000040106c      11              f(0x100)</span><br><span class="line">(gdb) ni</span><br><span class="line">0x000000000040106f      11              f(0x100)</span><br><span class="line">(gdb) disassemble</span><br><span class="line">Dump of assembler code for function main.main:</span><br><span class="line">  0x0000000000401040 &lt;+0&gt;:     mov    %fs:0xfffffffffffffff8,%rcx</span><br><span class="line">  0x0000000000401049 &lt;+9&gt;:     cmp    0x10(%rcx),%rsp</span><br><span class="line">  0x000000000040104d &lt;+13&gt;:    jbe    0x401086 &lt;main.main+70&gt;</span><br><span class="line">  0x000000000040104f &lt;+15&gt;:    sub    $0x10,%rsp</span><br><span class="line">  0x0000000000401053 &lt;+19&gt;:    lea    0x88316(%rip),%rbx        # 0x489370 &lt;main.main.func1.f&gt;</span><br><span class="line">  0x000000000040105a &lt;+26&gt;:    mov    %rbx,0x8(%rsp)</span><br><span class="line">  0x000000000040105f &lt;+31&gt;:    movq   $0x100,(%rsp)</span><br><span class="line">  0x0000000000401067 &lt;+39&gt;:    mov    0x8(%rsp),%rbx</span><br><span class="line">  0x000000000040106c &lt;+44&gt;:    mov    %rbx,%rdx</span><br><span class="line">&#x3D;&gt; 0x000000000040106f &lt;+47&gt;:    mov    (%rdx),%rbx</span><br><span class="line">  0x0000000000401072 &lt;+50&gt;:    callq  *%rbx</span><br><span class="line">  0x0000000000401074 &lt;+52&gt;:    movq   $0x100,(%rsp)</span><br><span class="line">  0x000000000040107c &lt;+60&gt;:    callq  0x401000 &lt;main.myFunc&gt;</span><br><span class="line">  0x0000000000401081 &lt;+65&gt;:    add    $0x10,%rsp</span><br><span class="line">  0x0000000000401085 &lt;+69&gt;:    retq</span><br><span class="line">  0x0000000000401086 &lt;+70&gt;:    callq  0x44b040 &lt;runtime.morestack_noctxt&gt;</span><br><span class="line">  0x000000000040108b &lt;+75&gt;:    jmp    0x401040 &lt;main.main&gt;</span><br><span class="line">  0x000000000040108d &lt;+77&gt;:    int3</span><br><span class="line">  0x000000000040108e &lt;+78&gt;:    int3</span><br><span class="line">  0x000000000040108f &lt;+79&gt;:    int3</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) ni</span><br><span class="line">0x0000000000401072      11              f(0x100)</span><br><span class="line">(gdb) p $rbx</span><br><span class="line">$5 &#x3D; 4198544</span><br><span class="line">(gdb) i r</span><br><span class="line">rax            0xc820000180     859530330496</span><br><span class="line">rbx            0x401090 4198544</span><br><span class="line">...</span><br><span class="line">(gdb) x&#x2F;1xg 0x401090</span><br><span class="line">0x401090 &lt;main.main.func1&gt;:     0xfffff8250c8b4864</span><br></pre></td></tr></table></figure>

<p>接着往下执行到 +47 这一行，可以看到 <code>rbx</code> 里面的值在这一行会有变化，<code>ni</code> 执行完这一行，输出寄存器的内容看一下，然后显示 <code>rbx</code> 指向的内存可以看到我们的匿名函数 <code>func1</code>。</p>
<p>现在基本可以理清 <code>Go</code> 里面匿名函数与正常的函数区别，参数的传递区别不大，只是在调用方面，匿名函数需要通过一个包装对象<code>func1.f</code> 来调用匿名函数，这个过程通过 <code>rbx</code> 进行二次寻址来完成调用。理论上，匿名函数也会比正常函数性能要差。</p>
<h3 id="Go中闭包的实现"><a href="#Go中闭包的实现" class="headerlink" title="Go中闭包的实现"></a>Go中闭包的实现</h3><p>实际上，Go在底层是用一个结构体来表示闭包，该结构体保存着闭包的匿名函数和引用变量：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Closure <span class="keyword">struct</span> &#123;</span><br><span class="line">    F <span class="function"><span class="keyword">func</span><span class="params">()</span></span> </span><br><span class="line">    i *<span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下面代码为例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span>&#123;</span><br><span class="line">        foo := <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">                foo++</span><br><span class="line">                <span class="keyword">return</span> foo</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        bar := myFunc()</span><br><span class="line">        value_1 := bar()</span><br><span class="line">        value_2 := bar()</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println</span>(value_1) <span class="comment">// 1</span></span><br><span class="line">        <span class="built_in">println</span>(value_2) <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与分析匿名函数的过程一样，编译后通过gdb来跟踪。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ go build -gcflags &quot;-N -l -m&quot;  closure_func.go</span><br><span class="line"># command-line-arguments</span><br><span class="line">.&#x2F;closure_func.go:5: func literal escapes to heap</span><br><span class="line">.&#x2F;closure_func.go:5: func literal escapes to heap</span><br><span class="line">.&#x2F;closure_func.go:4: moved to heap: foo</span><br><span class="line">.&#x2F;closure_func.go:6: &amp;foo escapes to heap</span><br><span class="line"></span><br><span class="line">$ gdb closure_func</span><br><span class="line">(gdb) b main.main</span><br><span class="line">Breakpoint 1 at 0x4010d0: file &#x2F;root&#x2F;data&#x2F;example&#x2F;closures&#x2F;closure_func.go, line 11.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: &#x2F;root&#x2F;data&#x2F;example&#x2F;closures&#x2F;closure_func</span><br><span class="line">[New LWP 5367]</span><br><span class="line">[New LWP 5368]</span><br><span class="line">[New LWP 5370]</span><br><span class="line">[New LWP 5369]</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main.main () at &#x2F;root&#x2F;data&#x2F;example&#x2F;closures&#x2F;closure_func.go:11</span><br><span class="line">11      func main() &#123;</span><br><span class="line">(gdb) i locals</span><br><span class="line">value_2 &#x3D; 859530428512</span><br><span class="line">value_1 &#x3D; 0</span><br><span class="line">bar &#x3D; &#123;void (int *)&#125; 0xc820039f40</span><br></pre></td></tr></table></figure>

<p><code>gdb</code> 在 <code>main.main</code> 设置断点并输出环境变量可以看到 <code>bar</code>，而且 <code>bar</code> 是一个指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) i r</span><br><span class="line">rax            0x80000  524288</span><br><span class="line">rbx            0xc82000a140     859530371392</span><br><span class="line">...</span><br><span class="line">(gdb) x&#x2F;2xg 0xc82000a140</span><br><span class="line">0xc82000a140:   0x0000000000401170      0x000000c82000a0b8</span><br><span class="line">(gdb) x&#x2F;2xg 0x0000000000401170</span><br><span class="line">0x401170 &lt;main.myFunc.func1&gt;:   0x085a8b4810ec8348      0x44c74808245c8948</span><br></pre></td></tr></table></figure>

<p>输出寄存器的信息，能够发现寄存器 <code>rbx</code> 与之前匿名函数的作用类似，都指向了闭包返回对象。里面封装着我们需要用到的匿名函数。可以看到匿名函数作为返回结果，整个调用过程跟是否形成闭包区别不大。那这个区别在哪里呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">(gdb) ni</span><br><span class="line">0x00000000004010fc      13              value_1 :&#x3D; bar()</span><br><span class="line">(gdb) si</span><br><span class="line">main.myFunc.func1 (~r0&#x3D;859530371392) at &#x2F;root&#x2F;data&#x2F;example&#x2F;closures&#x2F;closure_func.go:5</span><br><span class="line">5               return func() int &#123;</span><br><span class="line">(gdb) disassemble</span><br><span class="line">Dump of assembler code for function main.myFunc.func1:</span><br><span class="line">&#x3D;&gt; 0x0000000000401170 &lt;+0&gt;:     sub    $0x10,%rsp</span><br><span class="line">  0x0000000000401174 &lt;+4&gt;:     mov    0x8(%rdx),%rbx</span><br><span class="line">  0x0000000000401178 &lt;+8&gt;:     mov    %rbx,0x8(%rsp)</span><br><span class="line">  0x000000000040117d &lt;+13&gt;:    movq   $0x0,0x18(%rsp)</span><br><span class="line">  0x0000000000401186 &lt;+22&gt;:    mov    0x8(%rsp),%rbx</span><br><span class="line">  0x000000000040118b &lt;+27&gt;:    mov    (%rbx),%rbp</span><br><span class="line">  ...</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) i r</span><br><span class="line">rax            0x80000  524288</span><br><span class="line">rbx            0x401170 4198768</span><br><span class="line">rcx            0xc820000180     859530330496</span><br><span class="line">rdx            0xc82000a140     859530371392</span><br><span class="line">...</span><br><span class="line">(gdb) x&#x2F;2xg 0xc82000a140</span><br><span class="line">0xc82000a140:   0x0000000000401170      0x000000c82000a0b8</span><br><span class="line">(gdb) x&#x2F;2xg 0x0000000000401170</span><br><span class="line">0x401170 &lt;main.myFunc.func1&gt;:   0x085a8b4810ec8348      0x44c74808245c8948</span><br><span class="line">(gdb) x&#x2F;2xg 0x000000c82000a0b8</span><br><span class="line">0xc82000a0b8:   0x0000000000000000      0x3d534e4d554c4f43</span><br></pre></td></tr></table></figure>

<p><code>si</code> 进入到匿名函数内部。在 <code>func1</code> 内部可以看到从 <code>rdx</code> 取数据。输出 <code>rdx</code> 内容，可以看到前面指向匿名函数，而后面则指向引用变量 <code>0x0000000000000000</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b 14</span><br><span class="line">Breakpoint 2 at 0x401107: file &#x2F;root&#x2F;data&#x2F;example&#x2F;closures&#x2F;closure_func.go, line 14.</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 2, main.main () at &#x2F;root&#x2F;data&#x2F;example&#x2F;closures&#x2F;closure_func.go:14</span><br><span class="line">14              value_2 :&#x3D; bar()</span><br><span class="line">14              value_2 :&#x3D; bar()</span><br><span class="line">(gdb) disassemble</span><br><span class="line">Dump of assembler code for function main.main:</span><br><span class="line">  0x00000000004010d0 &lt;+0&gt;:     mov    %fs:0xfffffffffffffff8,%rcx</span><br><span class="line">  0x00000000004010d9 &lt;+9&gt;:     cmp    0x10(%rcx),%rsp</span><br><span class="line">  0x00000000004010dd &lt;+13&gt;:    jbe    0x40115c &lt;main.main+140&gt;</span><br><span class="line">  0x00000000004010df &lt;+15&gt;:    sub    $0x20,%rsp</span><br><span class="line">  0x00000000004010e3 &lt;+19&gt;:    callq  0x401000 &lt;main.myFunc&gt;</span><br><span class="line">  0x00000000004010e8 &lt;+24&gt;:    mov    (%rsp),%rbx</span><br><span class="line">  0x00000000004010ec &lt;+28&gt;:    mov    %rbx,0x18(%rsp)</span><br><span class="line">  0x00000000004010f1 &lt;+33&gt;:    mov    0x18(%rsp),%rbx</span><br><span class="line">  0x00000000004010f6 &lt;+38&gt;:    mov    %rbx,%rdx</span><br><span class="line">  0x00000000004010f9 &lt;+41&gt;:    mov    (%rdx),%rbx</span><br><span class="line">  0x00000000004010fc &lt;+44&gt;:    callq  *%rbx</span><br><span class="line">  0x00000000004010fe &lt;+46&gt;:    mov    (%rsp),%rbx</span><br><span class="line">  0x0000000000401102 &lt;+50&gt;:    mov    %rbx,0x10(%rsp)</span><br><span class="line">&#x3D;&gt; 0x0000000000401107 &lt;+55&gt;:    mov    0x18(%rsp),%rbx</span><br><span class="line">  0x000000000040110c &lt;+60&gt;:    mov    %rbx,%rdx</span><br><span class="line">  0x000000000040110f &lt;+63&gt;:    mov    (%rdx),%rbx</span><br><span class="line">  0x0000000000401112 &lt;+66&gt;:    callq  *%rbx</span><br><span class="line">  0x0000000000401114 &lt;+68&gt;:    mov    (%rsp),%rbx</span><br><span class="line">  ...</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) ni 3</span><br><span class="line">0x0000000000401112      14              value_2 :&#x3D; bar()</span><br><span class="line">(gdb) disassemble</span><br><span class="line">Dump of assembler code for function main.main:</span><br><span class="line">  0x00000000004010d0 &lt;+0&gt;:     mov    %fs:0xfffffffffffffff8,%rcx</span><br><span class="line">  0x00000000004010d9 &lt;+9&gt;:     cmp    0x10(%rcx),%rsp</span><br><span class="line">  0x00000000004010dd &lt;+13&gt;:    jbe    0x40115c &lt;main.main+140&gt;</span><br><span class="line">  0x00000000004010df &lt;+15&gt;:    sub    $0x20,%rsp</span><br><span class="line">  0x00000000004010e3 &lt;+19&gt;:    callq  0x401000 &lt;main.myFunc&gt;</span><br><span class="line">  0x00000000004010e8 &lt;+24&gt;:    mov    (%rsp),%rbx</span><br><span class="line">  0x00000000004010ec &lt;+28&gt;:    mov    %rbx,0x18(%rsp)</span><br><span class="line">  0x00000000004010f1 &lt;+33&gt;:    mov    0x18(%rsp),%rbx</span><br><span class="line">  0x00000000004010f6 &lt;+38&gt;:    mov    %rbx,%rdx</span><br><span class="line">  0x00000000004010f9 &lt;+41&gt;:    mov    (%rdx),%rbx</span><br><span class="line">  0x00000000004010fc &lt;+44&gt;:    callq  *%rbx</span><br><span class="line">  0x00000000004010fe &lt;+46&gt;:    mov    (%rsp),%rbx</span><br><span class="line">  0x0000000000401102 &lt;+50&gt;:    mov    %rbx,0x10(%rsp)</span><br><span class="line">  0x0000000000401107 &lt;+55&gt;:    mov    0x18(%rsp),%rbx</span><br><span class="line">  0x000000000040110c &lt;+60&gt;:    mov    %rbx,%rdx</span><br><span class="line">  0x000000000040110f &lt;+63&gt;:    mov    (%rdx),%rbx</span><br><span class="line">&#x3D;&gt; 0x0000000000401112 &lt;+66&gt;:    callq  *%rbx</span><br><span class="line">  0x0000000000401114 &lt;+68&gt;:    mov    (%rsp),%rbx</span><br><span class="line">  ...</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) si</span><br><span class="line">main.myFunc.func1 (~r0&#x3D;1) at &#x2F;root&#x2F;data&#x2F;example&#x2F;closures&#x2F;closure_func.go:5</span><br><span class="line">5               return func() int &#123;</span><br><span class="line">(gdb) disassemble</span><br><span class="line">Dump of assembler code for function main.myFunc.func1:</span><br><span class="line">&#x3D;&gt; 0x0000000000401170 &lt;+0&gt;:     sub    $0x10,%rsp</span><br><span class="line">  0x0000000000401174 &lt;+4&gt;:     mov    0x8(%rdx),%rbx</span><br><span class="line">  0x0000000000401178 &lt;+8&gt;:     mov    %rbx,0x8(%rsp)</span><br><span class="line">  0x000000000040117d &lt;+13&gt;:    movq   $0x0,0x18(%rsp)</span><br><span class="line">  0x0000000000401186 &lt;+22&gt;:    mov    0x8(%rsp),%rbx</span><br><span class="line">  0x000000000040118b &lt;+27&gt;:    mov    (%rbx),%rbp</span><br><span class="line">  ...</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) i r</span><br><span class="line">rax            0x80000  524288</span><br><span class="line">rbx            0x401170 4198768</span><br><span class="line">rcx            0xc820000180     859530330496</span><br><span class="line">rdx            0xc82000a140     859530371392</span><br><span class="line">...</span><br><span class="line">(gdb) x&#x2F;2xg 0xc82000a140</span><br><span class="line">0xc82000a140:   0x0000000000401170      0x000000c82000a0b8</span><br><span class="line">(gdb) x&#x2F;2xg 0x000000c82000a0b8</span><br><span class="line">0xc82000a0b8:   0x0000000000000001      0x3d534e4d554c4f43</span><br><span class="line">(gdb) i locals</span><br><span class="line">&amp;foo &#x3D; 0xc82000a0b8</span><br></pre></td></tr></table></figure>

<p>设置断点进入到下一次闭包内，输出相同的内容，会发现 <code>rdx</code> 后半段指向的引用变量发生了变化。通过 <code>i locals</code> 查看环境变量，可以看到 foo 的地址是 <code>0xc82000a0b8</code> ， 跟 <code>rdx</code> 的后半段内容一样。</p>
<h2 id="闭包变量逃逸"><a href="#闭包变量逃逸" class="headerlink" title="闭包变量逃逸"></a>闭包变量逃逸</h2><p>闭包可能会导致变量逃逸到堆上来延长变量的生命周期，给GC带来压力</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Closures</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(a <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">		x++</span><br><span class="line">		<span class="keyword">return</span> a + x</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	A := Closures()</span><br><span class="line">	fmt.Println(A(<span class="number">1</span>))</span><br><span class="line">	fmt.Println(A(<span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行如下指令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -gcflags <span class="string">&quot;-N -l -m&quot;</span> closure  </span><br></pre></td></tr></table></figure>

<p>结果如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Closures</span><br><span class="line">.&#x2F;Closures.go:8:6: moved to heap: x</span><br><span class="line">.&#x2F;Closures.go:9:9: func literal escapes to heap</span><br><span class="line">.&#x2F;Closures.go:17:13: ... argument does not escape</span><br><span class="line">.&#x2F;Closures.go:17:15: A(1) escapes to heap</span><br><span class="line">.&#x2F;Closures.go:18:13: ... argument does not escape</span><br><span class="line">.&#x2F;Closures.go:18:15: A(2) escapes to heap</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/29/GoClosure/" data-id="ckoaeq7vg0005p8v396cu1ovj" data-title="Go闭包" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go/" rel="tag">Go</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/05/02/unsafePointerUintptr/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          unsafePointerUintptr
        
      </div>
    </a>
  
  
    <a href="/2021/04/26/goDeclarationSyntax/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">Go&#39;s Declaration Syntax翻译</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Go/" rel="tag">Go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Go/" style="font-size: 20px;">Go</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/05/10/GoInterface/">初识Go接口</a>
          </li>
        
          <li>
            <a href="/2021/05/09/GoReceiverInterface/">Go值接收者和指针接收者</a>
          </li>
        
          <li>
            <a href="/2021/05/02/unsafePointerUintptr/">unsafePointerUintptr</a>
          </li>
        
          <li>
            <a href="/2021/04/29/GoClosure/">Go闭包</a>
          </li>
        
          <li>
            <a href="/2021/04/26/goDeclarationSyntax/">Go&#39;s Declaration Syntax翻译</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 ZiggyJiang的博客<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>